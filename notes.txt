; Vjobs:


; -----------------------------------------------------------------------------
; Handling vram loading via a video job (vjob) format
; -----------------------------------------------------------------------------

  .equ VJOB_MAX 8 ; amount of video jobs the table can hold 

.struct vjob
  bank db
  source dw
  size dw
  destination dw
.endst



.ramsection "Vjob RAM" slot 3
  vjobs db
  vjob_table dsb 2*VJOB_MAX 
.ends

.section "Video jobs" free
  initialize_vjobs:
    ; Does not take any parameters
    xor a
    ld (vjobs),a
  ret
  
  add_vjob:
    ; HL: Video job to add to table
    ld a,(vjobs)
    cp VJOB_MAX
    ret z                       ; Protect against overflow..
    ;
    ld b,l
    ld c,h
    push bc
      ld a,(vjobs)
      ld hl,vjob_table
      call offset_word_table
    pop bc
    ld (hl),b
    inc hl
    ld (hl),c
    ;
    ld hl,vjobs
    inc (hl)
  ret
  
  process_vjobs:
    ; Does not take any parameters
    ld a,(vjobs)
    cp 0
    ret z
    ld b,0
    ld c,a
    -:
        push bc
          ld a,b
          ld hl,vjob_table
          call offset_word_table
          call get_word
          call run_vjob
        pop bc
      inc b
      ld a,c
      cp b
    jp nz,-
    ;
    xor a
    ld (vjobs),a
  ret

  run_vjob:
    ; HL: Pointer to video job to run.
    push hl
    pop ix
    ld a,(ix+0)
    SELECT_BANK_IN_REGISTER_A
    ld l,(ix+1)
    ld h,(ix+2)
    ld c,(ix+3)
    ld b,(ix+4)
    ld e,(ix+5)
    ld d,(ix+6)
    call load_vram
  ret
.ends



     
     
     ; ------------
     
     ; Test to get ENABLED staus from the anim in slot 0.
    LOAD_ACM fake_acm_data
    ld a,0
    call is_animation_enabled
    ASSERT_A_EQUALS TRUE

    ; Test to get DISABLED staus from the anim in slot 1.
    LOAD_ACM fake_acm_data
    ld a,1
    call is_animation_enabled
    ASSERT_A_EQUALS FALSE

    ; Test simple getters:
    LOAD_ACM fake_acm_data
    ld a,0
    call get_frame
    ASSERT_A_EQUALS 0
    ld a,2
    call get_frame
    ASSERT_A_EQUALS 1
    ld a,0
    call get_timer
    ASSERT_A_EQUALS 9
    ld a,2
    call get_timer
    ASSERT_A_EQUALS 0

    ; Test getting data from the animation file:
    LOAD_ACM fake_acm_data
    ld a,0
    call is_animation_looping
    ASSERT_A_EQUALS TRUE

    ; Test btach ticking of enabled animations
    LOAD_ACM fake_acm_data
    call tick_enabled_animations
    ld a,0
    call get_timer
    ASSERT_A_EQUALS 8
    ld a,2
    call get_timer
    ASSERT_A_EQUALS 0
    ld a,7
    call get_timer
    ASSERT_A_EQUALS 9 

    ; Test max frame
    LOAD_ACM fake_acm_data
    ld a,0
    call is_animation_at_max_frame
    ASSERT_A_EQUALS FALSE
    ld a,2
    call is_animation_at_max_frame
    ASSERT_A_EQUALS TRUE

    ; Test disable non-looping animation at max frame:
    LOAD_ACM fake_acm_data
    ld a,2
    call is_animation_at_max_frame
    cp TRUE
    jp nz,+
      ld a,2
      call is_animation_looping
      cp FALSE
      jp nz,+
        ld a,2
        call disable_animation
    +:
    ld a,2
    call is_animation_enabled
    ASSERT_A_EQUALS FALSE

    ; Test getting info about current frame from file
    LOAD_ACM fake_acm_data
    ld a,0
    call get_duration
    ASSERT_A_EQUALS 10

    ; Test getting info about current frame from file
    LOAD_ACM fake_acm_data
    ld a,2
    call get_duration
    ASSERT_A_EQUALS 7
    ld a,0
    call get_duration
    ASSERT_A_EQUALS 10

    ; Test getting info about current frame from file
    LOAD_ACM fake_acm_data
    ld a,0
    call is_vjob_required
    ASSERT_A_EQUALS TRUE
    ld a,2
    call is_vjob_required
    ASSERT_A_EQUALS FALSE

    ; Test adding a vjob if the current frame requires it.
    LOAD_ACM fake_acm_data
    CLEAR_VJOBS
    ld a,2
    call add_vjob_if_required
    ld a,(vjobs)
    ASSERT_A_EQUALS 0

    ; Test adding a vjob if the current frame requires it.
    LOAD_ACM fake_acm_data
    CLEAR_VJOBS
    ld a,0
    call add_vjob_if_required
    ld a,(vjobs)
    ASSERT_A_EQUALS 1
    ld hl,vjob_table
    call get_word
    ASSERT_HL_EQUALS cody_walking_0_vjob

    ; Test adding a vjob if the current frame requires it.
    LOAD_ACM fake_acm_data
    CLEAR_VJOBS
    ld a,2
    call add_vjob_if_required
    ld a,(vjobs)
    ASSERT_A_EQUALS 0
    ld hl,vjob_table
    call get_word
    ASSERT_HL_EQUALS $0000

    ; Roll out the big batch tests:
    LOAD_ACM fake_acm_data_2
    CLEAR_VJOBS
    call process_animations
      ; Are timers handled as expected?
      ld a,0
      call get_timer
      ASSERT_A_EQUALS 8
      jp +
        timers_ticked_once:
          .db 8 0 0 2 0 0 0 9
      +:
      ld hl,acm_timer
      ASSERT_HL_POINTS_TO_STRING ACM_SLOTS timers_ticked_once

    ; Test incrementing frame
    LOAD_ACM fake_acm_data_2
    CLEAR_VJOBS
    call process_animations
    ld a,2
    call get_frame
    ASSERT_A_EQUALS 1
    
    ; Test looping, part one
    LOAD_ACM fake_acm_data_3
    CLEAR_VJOBS
    call process_animations
    ld a,7
    call get_frame
    ASSERT_A_EQUALS_NOT 2

    ; Further testing incrementing frame
    LOAD_ACM fake_acm_data_3
    CLEAR_VJOBS
    call process_animations
    ld a,2
    call get_frame
    ASSERT_A_EQUALS 1
    ld a,2
    call get_duration
    ASSERT_A_EQUALS 7
    ld a,2
    call get_timer
    ASSERT_A_EQUALS 7

  ; Test looping, part two
    LOAD_ACM fake_acm_data_3
    CLEAR_VJOBS
    call process_animations
    ld a,7
    call get_frame
    ASSERT_A_EQUALS 0

  ; Test looping, part three - no loop, just disable
    LOAD_ACM fake_acm_data_2
    CLEAR_VJOBS
    call process_animations
    ld a,2
    call get_frame
    ASSERT_A_EQUALS 1

    ; This is going well...!


    ; Test get animation label.
    LOAD_ACM fake_acm_data_3
    CLEAR_VJOBS
    ld a,0
    call get_animation_label
    ASSERT_HL_EQUALS cody_walking

    ; Test adding an animation, the pointer.
    LOAD_ACM fake_acm_data_3
    CLEAR_VJOBS
    ld a,1
    call get_animation_label
    ASSERT_HL_EQUALS $0000
    ld a,1
    ld hl,cody_walking
    call set_animation
    ld a,1
    call get_animation_label
    ASSERT_HL_EQUALS cody_walking
    ld a,1
    call get_timer
    ASSERT_A_EQUALS 10
    ld a,1
    call is_vjob_required
    ASSERT_A_EQUALS TRUE

    ld a,0
    call get_layout
    ASSERT_A_EQUALS 1
    ld a,b
    ASSERT_A_EQUALS 8
    ASSERT_HL_EQUALS layout_2x4
    ld a,(hl)
    ASSERT_A_EQUALS -32
    ASSERT_HL_POINTS_TO_STRING 8,layout_2x4



    .macro CLEAR_SAT_BUFFER
      ld a,0
      ld (sat_buffer_index),a
      ld hl,sat_buffer_y
      .rept 64
        ld (hl),a
        inc hl
      .endr
      ld hl,sat_buffer_xc
      .rept 128
        ld (hl),a
        inc hl
      .endr
    .endm

    jp +
      .dstruct fake_actor actor 0, 100, 100
    +:
    jp +
      offset_fake_actor:
        .db 68 68 76 76 84 84 92 92
      offset_fake_actor_xc:
        .db 92, 1, 100, 2, 92, 3, 100, 4
    +:

    ; Test sat y buffer.
    CLEAR_SAT_BUFFER
    LOAD_ACM fake_acm_data_3
    CLEAR_VJOBS
    ld a,0  ; use frame currently displaying in slot 0.
    ld hl,fake_actor
    call draw_actor
    ld hl,sat_buffer_y
    ASSERT_HL_POINTS_TO_STRING 8, offset_fake_actor

  ; Test sat xc buffer.
    CLEAR_SAT_BUFFER
    LOAD_ACM fake_acm_data_3
    CLEAR_VJOBS
    ld a,0  ; use frame currently displaying in slot 0.
    ld hl,fake_actor
    call draw_actor
    ld hl,sat_buffer_xc
    ld a,(hl)
    ASSERT_A_EQUALS 92
    ASSERT_HL_POINTS_TO_STRING 6, offset_fake_actor_xc

    ;----------------------------------------------------------
 
 
 
  .macro INITIALIZE_ACTOR
    ld hl,init_data_\@
    ld de,\1
    ld bc,3
    ldir
    jp +
      init_data_\@:
        .db \2 \3 \4 
    +:
    ld a,\2
    ld hl,\5
    call set_frame

  .endm

      ;
    ld hl,mockup_tiles_job
    call add_vjob
    ld hl,mockup_tilemap_job
    call add_vjob
    call process_vjobs

  
   .section "Drawing and animating actors" free
  get_frame:
    ; IN: A = Index
    ; OUT: HL = pointer to frame item.
    ld hl,frame_table
    ld b,_sizeof_frame
    call offset_custom_table
  ret

  set_frame:
    ; Copy an frame struct item into the table at index.
    ; IN: A = Index, HL = frame struct
    push hl
      ld hl,frame_table
      ld b,_sizeof_frame
      call offset_custom_table
      ex de,hl
    pop hl
    ld bc,_sizeof_frame
    ldir
  ret

  draw_actor:
    ; Put the current frame of a given actor into the SAT buffer. 
    ; HL = Pointer to actor struct
    ld a,(hl) ; get id
    inc hl
    ld d,(hl)
    inc hl
    ld e,(hl)
    call get_frame
    ld b,(hl)
    inc hl
    call get_word
    push hl
    pop ix
    -:
      call add_sprite
      inc ix
      inc ix
      inc ix
    djnz -    
  ret
.ends




  ; Test false and zeroes
  ld hl,fake_frame_video_job_list_no_jobs
  ld a,3
  call get_frame_video_job
  ASSERT_A_EQUALS FALSE
  ASSERT_HL_EQUALS $0000

  ; Test false 
  ld hl,fake_frame_video_job_list_no_jobs
  ld a,0
  call get_frame_video_job
  ASSERT_A_EQUALS FALSE
  ASSERT_HL_EQUALS cody_walking_0_tiles_job

  ; Test video job info for frame 0
  ld hl,fake_frame_video_job_list
  ld a,0
  call get_frame_video_job
  ASSERT_A_EQUALS TRUE



  ; Test tick 10 to 9.
  jp +  
    ; Fake RAM structure.
    .dstruct anim_0_10 animation 0, 10, fake_anim_script
  +:
  ld hl,anim_0_10
  call tick_animation
  ASSERT_A_EQUALS 9

  ; Test tick 1 to 0.
  jp +  
    ; Fake RAM structure.
    .dstruct anim_0_1 animation 0, 1, fake_anim_script
  +:
  ld hl,anim_0_1
  call tick_animation
  ASSERT_A_EQUALS 0

  ; Test tick 0 to ANIM_TIMER_UP.
  jp +  
    ; Fake RAM structure.
    .dstruct anim_0_0 animation 0, 0, fake_anim_script
  +:
  ld hl,anim_0_0
  call tick_animation
  ASSERT_A_EQUALS ANIM_TIMER_UP

  ; Test get next frame
  ld hl,anim_0_0
  call get_next_frame
  ASSERT_A_EQUALS 1

  jp +  
    ; Fake RAM structure.
    .dstruct anim_3_0 animation 3, 0, fake_anim_script
  +:
  ; Test get next frame when looping
  ld hl,anim_3_0
  call get_next_frame
  ASSERT_A_EQUALS 0

  jp +  
    ; Fake RAM structure.
    .dstruct anim_3_0_noloop animation 3, 0, fake_anim_script_no_loop
  +:
  ; Test get next frame when looping
  ld hl,anim_3_0_noloop
  call get_next_frame
  ASSERT_A_EQUALS 3

  jp +  
    ; Fake RAM structure.
    .dstruct anim_1_0 animation 1, 0, fake_anim_script
  +:
  ; Test get data for frame 1
  ld hl,anim_1_0
  call get_ticks_and_frame_pointer
  ASSERT_A_EQUALS 10
  ASSERT_HL_EQUALS cody_walking_1_and_3

  jp +  
    ; Fake RAM structure.
    .dstruct anim_2_0 animation 2, 0, fake_anim_script
  +:
  ; Test get data for frame 2
  ld hl,anim_2_0
  call get_ticks_and_frame_pointer
  ASSERT_A_EQUALS 10
  ASSERT_HL_EQUALS cody_walking_2


   
    jp +
    ; Data for testing the animations
    fake_anim_script:
      .db 3                       ; Max frame
      .db TRUE                    ; Looping
      .db 10                      ; Ticks to display frame
      .dw cody_walking_0          ; Frame
      .db 10    
      .dw cody_walking_1_and_3
      .db 10    
      .dw cody_walking_2
      .db 10    
      .dw cody_walking_1_and_3
 
    fake_anim_script_no_loop:
      .db 3                       ; Max frame
      .db FALSE                    ; Looping
      .db 10                      ; Ticks to display frame
      .dw cody_walking_0          ; Frame
      .db 10    
      .dw cody_walking_1_and_3
      .db 10    
      .dw cody_walking_2
      .db 10    
      .dw cody_walking_1_and_3

    fake_frame_video_job_list:          
      .db TRUE                        ; Perform video job?
      .dw cody_walking_0_tiles_job    ; Pointer to video job or $0000 if FALSE
      .db TRUE
      .dw cody_walking_1_and_3_tiles_job
      .db TRUE
      .dw cody_walking_2_tiles_job
      .db TRUE
      .dw cody_walking_1_and_3_tiles_job

    fake_frame_video_job_list_no_jobs:          
      .db FALSE                        ; Perform video job?
      .dw cody_walking_0_tiles_job    ; Pointer to video job or $0000 if FALSE
      .db FALSE
      .dw cody_walking_1_and_3_tiles_job
      .db FALSE
      .dw cody_walking_2_tiles_job
      .db FALSE
      .dw $0000
  +:

      .dstruct cody_walking animation 0, 10, cody_walking_anim_script
  
  cody_walking_anim_script:
    .db 3                       ; Max frame
    .db TRUE                    ; Looping
    .db 10                      ; Ticks to display frame
    .dw cody_walking_0          ; Frame
    .db 10    
    .dw cody_walking_1_and_3
    .db 10    
    .dw cody_walking_2
    .db 10    
    .dw cody_walking_1_and_3 

  cody_walking_frame_video_job_list:          
    .db TRUE                        ; Perform video job?
    .dw cody_walking_0_tiles_job    ; Pointer to video job or $0000 if FALSE
    .db TRUE
    .dw cody_walking_1_and_3_tiles_job
    .db TRUE
    .dw cody_walking_2_tiles_job
    .db TRUE
    .dw cody_walking_1_and_3_tiles_job
    
    ; FIXME: This needs to loop through all possible animations.
    ld a,(animation_table_index)
    cp 0
    jp z,_skip_anims

    .macro PROCESS_ANIMATION
      .redefine _OFFSET = \1*_sizeof_animation
      ld hl,animation_table+_OFFSET
      call tick_animation
      ld (animation_table + _OFFSET+ animation.timer),a
      cp ANIM_TIMER_UP
      jp nz,+
        ld hl,animation_table + _OFFSET
        call get_next_frame
        ld (animation_table + _OFFSET + animation.current_frame),a ; next frame
        ld hl,animation_table + _OFFSET
        call get_ticks_and_frame_pointer
        ld (animation_table + _OFFSET + animation.timer),a
        ld a,\1 ; hardcoded index in frame table (must be same as anim. index? - parallel)
        call set_frame
        
        ld hl,frame_video_job_table
        call get_word
        ld a,(animation_table + _OFFSET + animation.current_frame)
        call get_frame_video_job                ; Parallel 
        cp TRUE
        jp nz,+
          call add_video_job
      +:

    .endm

    PROCESS_ANIMATION 0

  _skip_anims:


    ld hl,cody
    call draw_actor
    ld hl,cody_twin
    call draw_actor

  
  
  init_animation_table:
    xor a
    ld (animation_table_index),a
  ret

  set_frame_video_job_list:
    ; Put a pointer to a video job list into the frame video jobs table.
    ; IN: HL = Pointer to video job list
    ;     A = animation table index
    ex de,hl
    ld hl,frame_video_job_table
    call offset_word_table
    ld (hl),e
    inc hl
    ld (hl),d
  
  ret


  set_animation:
    ; IN: A = Animation table index.
    ;     HL = Pointer to animation struct.
    ; TODO: Test to see if limit reached, then abort!
    ex de,hl
    ld b,_sizeof_animation
    ld hl,animation_table
    call offset_custom_table
    ex de,hl
    ld bc,_sizeof_animation
    ldir

  ret

  get_frame_video_job:
    ; Given a frame video job list and a frame number, get the information
    ; regarding video job for this frame
    ; IN: HL = Pointer to frame video job list
    ;     A = frame number
    ; OUT: A = Video job TRUE / FALSE, HL = Video job or undefined
    ld b,_sizeof_frame_video_job
    call offset_custom_table
    ld a,(HL)
    push af ; preserve the TRUE/FALSE
      inc hl
      call get_word
    pop af
  ret
  
  get_ticks_and_frame_pointer:
  ; Use the current_frame property of a given animation struct to look up
  ; it's associated script and return the scripted ticks and pointer to 
  ; frame struct. Used when setting new frame.
  ; IN: HL = Animation struct.
  ; OUT: A = Tick, HL = Pointer to frame.
    ld a,(hl)                   ; Get current frame from anim. struct.
    ld c,a                      ; Save it in c.
    inc hl                      ; Forward to pointer to script.
    inc hl                      ; ...
    call get_word               ; Load script pointer into HL.
    inc hl                      ; Forward past the script header.
    inc hl                      ; ...
    ld a,c                      ; Retrieve current frame. 
    ld b,3                      ; This script section consists of 3 byte items.
    call offset_custom_table    ; Offset to script item for current frame.
    ld a,(hl)                   ; Read ticks into A.
    inc hl                      ; Foward to frame pointer.
    ld b,a                      ; Save the ticks in B.
    call get_word               ; Load script pointer into HL.
    ld a,b                      ; Return ticks to A.
  ret

  get_next_frame:
    ; Use the current frame and script of with a given animation to determine
    ; the next frame of that animation. 
    ; IN: HL = Animation struct
    ; OUT: A = next frame index.
    ld a,(hl)             ; Get current frame as per animation struct.
    push af               ; Save it in ix.
    pop ix
    inc hl                ; Forward HL past the animation timer to the script.
    inc hl                ; HL now points to the animation script item.
    call get_word         ; Make HL point to the actual script.
    ld a,(hl)             ; Get max frame from script.
    ld b,a                ; Save it in b.
    push ix               ; Retrieve current frame from ix. 
    pop af
    cp b                  ; Is current frame == max frame?
    jp z,+                ; Yes? - Jump forward to handle loop or still.
      inc a               ; No? - Just increment the frame counter.
      ret                 ; And return.
    +:               
      ; This is last (max) frame, what to do...?
      inc hl              ; Point HL to looping (true/false).
      ld a,(hl)           ; Get loop state.
      cp TRUE             ; Should we loop back to frame 0?
      jp z, +
        ld a,b            ; No - set the current frame as the next frame.
        ret               ; This keeps the animation still at the last frame.
      +:
        xor a             ; Yes - loop back to frame 0.
        ret               ; And return.
  
  .equ ANIM_TIMER_UP $ff
  tick_animation:
    ; Tick (decrement timer) of a given animation.
    ; IN: HL = Pointer to animation table item.
    ; OUT: A = New timer value or $ff for time up!
    ld de,animation.timer   ; Offset HL to animation timer.
    add hl,de               ;
    ld a,(hl)               ; Get current timer value.
    cp 0                    ; Is it 0?
    jp nz,+                 
      ld a,$ff              ; Timer is expired. Return special value.
      ret                   ; And return.
    +:
      dec a                 ; Timer not expired. Just decrement it.
  ret                       ; And return.



.struct animation
  ; Keeps track of current frame and the timer that counts down to
  ; when the current frame expires. Also points to the script that
  ; maps the frames and durations in the animation. 
  current_frame db
  timer db
  script dw
.endst
  ; Example_anim_script of a two-frame walking animation.
  ; my_anim_script:
  ;  .db 1                       ; Max frame (= 2 frames in total, 0-2)
  ;  .db TRUE                    ; Loop when last frame expires?
  ;  .db 10,                     ; Ticks to display frame.
  ;  .dw cody_walking_0          ; Frame.
  ;  .db 10                      ; etc...
  ;  .dw cody_walking_2

.struct frame
  ; Referenced by draw_actor, it controls how the current frame is manifested
  ; as offset y, x and char data, in the SAT buffer each frame.
  size db                       ; Amount of tiles / chars.
  layout dw                     ; Map with y,x-offsets and chars.
.endst
  ; Example frame struct and layout.
  ; .dstruct cody_walking_0 frame 4,layout_2x2
  ;  layout_2x2:
  ;  .db -32, -8, 1
  ;  .db -32, 0, 2
  ;  .db -24, -8, 3
  ;  .db -24, 0, 4

.struct frame_video_job
  ; For each frame in current animation, a three-byte entry. Can be used when
  ; a new frame is set, to load new tiles during the next vblank.
  perform_video_job db          ; TRUE or FALSE.
  video_job dw                  ; If TRUE, then add the job pointed to here.
.endst

.ramsection "Animation control matrix" slot 3
  ; Animation, frame and video jobs are rows indexed by columns of actor index.
  animation_table_index db
  animation_table dsb _sizeof_animation*ACTOR_MAX
  frame_table dsb _sizeof_frame*ACTOR_MAX
  frame_video_job_table dsb 2*ACTOR_MAX
.ends


----------------
.REDEFINE IF $0F
----------------

Assigns a new value or a string to an old definition. If the
definition doesn't exist, .REDEFINE performs .DEFINE's work.

When used with .REPT REDEFINE helps creating tables:

.DEFINE CNT 0

.REPT 256
.DB CNT
.REDEFINE CNT CNT+1
.ENDR


Documentation of the animation system.
3 structs, all three organized in parallel tables.
Actually, this creates a kind of matrix with the actor index.
  animation
    Keeping the frames together, and managing current frame, and counting
    down to next frame.
    - current frame
        The frame currently displaying.
    - timer
        ticks left of the current frame (from x to zero)
    - script
        A special data format for structuring the animation:
          max_frame (from 0 to max frame) -- header
          looping (true / false)          -- header
            3 byte items for each frame in animation:
              Ticks to display frame (byte)
              Pointer to frame struct (word)
          
  frame
    Referenced by draw_actor to put the tiles in the SAT buffer.
    - size 
        Number of tiles
    - layout from origin
        For all tiles in frame, offset y, x and the char(tile) number
  
  frame_video_job
    Can be used when a new frame is set, to load new tiles.  
    - perform video job (byte)
        Load new tiles, true or false. Adds a video job to the que.
    - video_job (word)
        If above is true, then treat this a pointer to the video job.

jp +

    xor a
    ld (temp_byte),a

  jp skip_gonzo
      ; gonzo test (kan evt. laves til en std. rythm)
      ld hl,temp_byte
      ld a,(hl)
      cp 192
      jp c,+
        ld a,0
        ld hl,cody_walking_0
        call set_frame
        ld hl,cody_walking_0_tiles_job
        call add_video_job
        jp +++
      +:
      ld a,(temp_byte)
      cp 128
      jp c,+
        ld a,0
        ld hl,cody_walking_1_and_3
        call set_frame
        ld hl,cody_walking_1_and_3_tiles_job
        call add_video_job
        jp +++
      +:
      ld a,(temp_byte)
      cp 64
      jp c,+
        ld a,0
        ld hl,cody_walking_2
        call set_frame
        ld hl,cody_walking_2_tiles_job
        call add_video_job
        jp +++
      +:
        ld a,0
        ld hl,cody_walking_1_and_3
        call set_frame
        ld hl,cody_walking_1_and_3_tiles_job
        call add_video_job    
      +++:
      ld hl,temp_byte
      inc (hl)
      inc (hl)
      inc (hl)
      inc (hl)
      inc (hl)
      inc (hl)
      inc (hl)
      inc (hl)
  skip_gonzo:




  fake_video_job_table: 
    .dw video_job_0
    .dw video_job_1
  fake_video_job_table_index:
    .db 0
  
  .dstruct video_job_0 instanceof video_job 2, multicolor_c, multicolor_c_size, $1234
  .dstruct video_job_1 instanceof video_job 2, multicolor_c, multicolor_c_size, $5678
  
  multicolor_c:
    .db $ff $00 $ff $00
    .db $00 $00 $c0 $c0
    .db $00 $00 $c0 $c0
    .db $00 $00 $c0 $c0
    .db $00 $00 $c0 $c0
    .db $00 $00 $c0 $c0
    .db $00 $00 $c0 $c0
    .db $00 $ff $00 $00
  multicolor_c_size:
    .dw 32
+:



  jp +
    fake_index:
      .db 0
    fake_job_table:
      .dw video_job_0
      .dw video_job_1
  +:
  ld a,(fake_index)
  ld hl,fake_job_table
  call offset_word_table
  call get_word
  ASSERT_HL_EQUALS video_job_0

  jp +
    fake_index_1:
      .db 1
    fake_job_table_1:
      .dw video_job_0
      .dw video_job_1
  +:
  ld a,(fake_index_1)
  ld hl,fake_job_table_1
  call offset_word_table
  call get_word
  ASSERT_HL_EQUALS video_job_1

  jp +
    .dstruct video_job_2 video_job 2, multicolor_c, multicolor_c_size, $1234
  +:
  RESET_TEST_KERNEL
  ld hl,video_job_2
  call run_video_job
  ld a,(test_kernel_bank)
  ASSERT_A_EQUALS 2
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $1234
  ld hl,test_kernel_bytes_written
  call get_word ;more like get value, or ptr2value16
  ASSERT_HL_EQUALS multicolor_c_size
  ld hl,test_kernel_source
  call get_word
  ASSERT_HL_EQUALS multicolor_c

  jp +
    fake_index_2:
      .db 1
    fake_job_table_2:
      .dw video_job_0
  +:
  RESET_TEST_KERNEL
  ld a,(fake_index_2)
  ld b,a
  -:
    push bc
      ld a,b
      dec a
      ld hl,fake_job_table_2
      call offset_word_table
      call get_word
      call run_video_job
    pop bc
  djnz -
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $1234

  jp +
    fake_video_jobs_3:
      .db 2
    fake_job_table_3:
      .dw video_job_0
      .dw video_job_1
  +:
  RESET_TEST_KERNEL
  ld a,(fake_video_jobs_3)
  ; todo: test if no jobs...
  -:
    push bc
      ld a,b
      ld hl,fake_job_table_3
      call offset_word_table
      call get_word
      call run_video_job
    pop bc
  dec b
  jp nz,-
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $5678

  jp +
    fake_video_jobs_4:
      .db 2
    fake_job_table_4:
      .dw video_job_0
      .dw video_job_1
  +:
  RESET_TEST_KERNEL
  ; load the test data into the correct memory position (set up parameters)...
  ld a,(fake_video_jobs_4)
  ld (video_jobs),a
  ld bc, 4
  ld hl,fake_job_table_4
  ld de,video_job_table
  ldir
  ;
  call process_video_job_table
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $5678



  
  ; Test reset test kernel
  RESET_TEST_KERNEL
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $0000


  .macro SETUP_VIDEO_JOB_TEST
    RESET_TEST_KERNEL
    ; Provide number of jobs, and job items in table
    ld a,\1
    ld (video_jobs),a
    ld bc, 2*(NARGS-1)
    jp +
      table_\@:
      .rept NARGS-1
        .shift
        .dw \1  
      .endr
    +:
    ld hl,table_\@
    ld de,video_job_table
    ldir
  .endm

  SETUP_VIDEO_JOB_TEST 2, video_job_0, video_job_1
  call process_video_job_table
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $5678

  ; Test no jobs
  SETUP_VIDEO_JOB_TEST 0, video_job_0, video_job_1
  call process_video_job_table
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $0000

  ; Test job 1 of two
  SETUP_VIDEO_JOB_TEST 1, video_job_0, video_job_1
  call process_video_job_table
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $1234

  jp +
    .dstruct video_job_3 video_job 2, multicolor_c, multicolor_c_size, $1111
  +:

  ; Test job 1 of three
  SETUP_VIDEO_JOB_TEST 1, video_job_0, video_job_1, video_job_3
  call process_video_job_table
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $1234

  ; Test job three of three
  SETUP_VIDEO_JOB_TEST 3, video_job_0, video_job_1, video_job_3
  call process_video_job_table
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $1111

  ; Test no jobs, but three (old) items on the list
  SETUP_VIDEO_JOB_TEST 0, video_job_0, video_job_1, video_job_3
  call process_video_job_table
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $0000

  ; Full test of last of two jobs, but three (old) items on the list
  SETUP_VIDEO_JOB_TEST 2, video_job_0, video_job_1, video_job_3
  call process_video_job_table
  ld a,(test_kernel_bank)
  ASSERT_A_EQUALS 2
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS $5678
  ld hl,test_kernel_bytes_written
  call get_word ;
  ASSERT_HL_EQUALS multicolor_c_size
  ld hl,test_kernel_source
  call get_word
  ASSERT_HL_EQUALS multicolor_c

  jp +
    .dstruct video_job_4 video_job 2, multicolor_c, multicolor_c_size, $4444
  +:

  ; Test video job table format
  SETUP_VIDEO_JOB_TEST 1, video_job_0
  ld hl,video_job_table
  call get_word
  ASSERT_HL_EQUALS video_job_0

  ; Test video job table format - with three jobs
  SETUP_VIDEO_JOB_TEST 3, video_job_0, video_job_1, video_job_2
  ld a,(video_jobs)
  dec a ; take it back to the last of the existing entries
  ld hl,video_job_table
  call offset_word_table
  call get_word
  ASSERT_HL_EQUALS video_job_2

  ; Test add video job - with three jobs
  SETUP_VIDEO_JOB_TEST 3, video_job_0, video_job_1, video_job_2
  ld hl,video_job_4
  call add_video_job

  ld a,(video_jobs)
  dec a ; take it back to the last of the existing entries
  ld hl,video_job_table
  call offset_word_table
  call get_word
  ASSERT_HL_EQUALS video_job_4


  ; Test add video job - with 0 jobs but filled table
  SETUP_VIDEO_JOB_TEST 0, video_job_0, video_job_1, video_job_2
  ld hl,video_job_4
  call add_video_job
  ;
  ld a,(video_jobs)
  dec a ; take it back to the last of the existing entries
  ld hl,video_job_table
  call offset_word_table
  call get_word
  ASSERT_HL_EQUALS video_job_4

  ; Test add video job - prevent overflow
  SETUP_VIDEO_JOB_TEST 10, video_job_0, video_job_1, video_job_2, video_job_0, video_job_1, video_job_2, video_job_0, video_job_1, video_job_2, video_job_0
  ld hl,video_job_4
  call add_video_job
  ;
  ld a,(video_jobs)
  dec a ; take it back to the last of the existing entries
  ld hl,video_job_table
  call offset_word_table
  call get_word
  ASSERT_HL_EQUALS video_job_0

  jp +
    ;.dstruct arthur_standing_0_job video_job 2, arthur_standing_0_tiles, CHARACTER_SIZE*7, SPRITE_BANK_START + CHARACTER_SIZE
  +:
  ; Test add video job - real arthur
  SETUP_VIDEO_JOB_TEST 0
  ld hl,arthur_standing_0_job
  call add_video_job
  ;
  ld a,(video_jobs)
  dec a ; take it back to the last of the existing entries
  ld hl,video_job_table
  call offset_word_table
  call get_word
  ASSERT_HL_EQUALS arthur_standing_0_job

    ; Full test of arthur job
  SETUP_VIDEO_JOB_TEST 1, arthur_standing_0_job
  call process_video_job_table
  ld a,(test_kernel_bank)
  ASSERT_A_EQUALS 2
  ld hl,test_kernel_destination
  call get_word
  ASSERT_HL_EQUALS SPRITE_BANK_START + CHARACTER_SIZE
  ld hl,test_kernel_bytes_written
  call get_word ;
  ASSERT_HL_EQUALS CHARACTER_SIZE*7
  ld hl,test_kernel_source
  call get_word
  ASSERT_HL_EQUALS arthur_standing_0_tiles


    ;ld bc,CHARACTER_SIZE*7
    ;ld de,SPRITE_BANK_START + CHARACTER_SIZE
    ;ld hl,arthur_standing_0_tiles
    ;call load_vram

    ;ld bc,96*CHARACTER_SIZE
    ;ld de,BACKGROUND_BANK_START
    ;ld hl,mockup_background_tiles
    ;call load_vram

    ld bc,VISIBLE_NAME_TABLE_SIZE
    ld de,NAME_TABLE_START
    ld hl,mockup_background_tilemap
    call load_vram





Feature request:
Add a tile loading que.
- Add item to que
- Remove item from que
Que can hold 8 loads (5 actors + 3 misc)
Items are pointers. Items are loads.
Load struct:
  source bank number
  ptr. to source
  bytes to load
  ptr. to destination i vram

  




   
     jp +
  batch_offset_input_0:
    .db 7, -24, -24, -16, -16, -8, -8, -32
  batch_offset_output_0:
    .db  126, 126, 134, 134, 142, 142, 118
  alternating_batch_offset_input_1:
    .db 7, -8, 1, 0, 2, -8, 3, 0, 4, -8, 5, 0, 6, -8, 7 ; pairs
  alternating_batch_offset_output_1:
    .db 142, 1, 150, 2, 142, 3, 150, 4, 142, 5, 150, 6, 142, 7
    ; fix?: let chars be a counter from x to x + size...?
  +:
  dec sp
  dec sp
  ld a,150
  ld hl,batch_offset_input_0
  call batch_offset_to_stack
  ASSERT_TOP_OF_STACK_EQUALS_STRING 7,batch_offset_output_0
  CLEAN_STACK 7

  ld a,150
  ld hl,batch_offset_input_0
  ld de,fake_sat_y
  call batch_offset_to_DE
  ld hl,fake_sat_y
  ASSERT_HL_EQUALS_STRING 7, batch_offset_output_0

  ld a,150
  ld hl,alternating_batch_offset_input_1
  ld de,fake_sat_xc
  call batch_alternating_offset_and_copy_to_DE
  ld hl,fake_sat_xc
  ASSERT_HL_EQUALS_STRING 14, alternating_batch_offset_output_1
   
    ld ix,arthur_twin
    ld iy,arthur_standing_0_frame    ;
    call draw_frame

  arthur_standing_0_y: ; batch format
    .db 7, -24, -24, -16, -16, -8, -8, -32

  arthur_standing_0_xc: ; batch format
    .db  7, -8, 1, 0, 2, -8, 3, 0, 4, -8, 5, 0, 6, -8, 7

  arthur_standing_0_frame: ; batch format
    .dw arthur_standing_0_y, arthur_standing_0_xc


  draw_frame:
    ; Draw an frame frame (metasprite) to SAT buffer.
    ; IN: IX = actor, IY = frame
    ld a,(sat_buffer_index)  
    ld hl,sat_buffer_y
    call offset_byte_table
    ex de,hl
    ld a,(ix+1)
    ld l,(iy+0)
    ld h,(iy+1)
    call batch_offset_to_DE

    ld a,(sat_buffer_index)  
    ld hl,sat_buffer_xc
    call offset_word_table
    ex de,hl
    ld a,(ix+2)
    ld l,(iy+2)
    ld h,(iy+3)
    call batch_alternating_offset_and_copy_to_DE

    ld l,(iy+0)
    ld h,(iy+1)
    ld a,(hl)
    ld b,a
    ld a,(sat_buffer_index)
    add a,b
    ld (sat_buffer_index),a
    ret


; -------------

.dstruct my_frame frame 7 arthur_standing_0_layout
test_size_in_my_frame:
  ld a,(my_frame.size)
  ASSERT_A_EQUALS 7
ret
  
  .struct frame
    size db
    layout dw
  .endst

Feature request:
Given an origin y,x and a pointer to a frame, must display frame.
Display frame: Load a number og appropritate sprites (yxc) into SAT.

Arthur standing 0: 7 sprites, >> 1 sprite


  get_sprite:
    ; A = index of sprite in layout
    ; HL = ptr to frame
    push af
      inc hl ; go past size
      call get_address
    pop af
    ld b,3
    call offset_custom_table

  ret


  my_sub:
    ld hl,2
    add hl,sp
    ld a,(hl)
    inc hl
    ld e,(hl)
    inc hl
    ld d,(hl)
    inc hl
    ; results , 2 bytes
    ld a,$12
    ld (hl),a
    inc hl
    ld a,$34
    ld (hl),a
    inc hl
  ret

  my_sub_gets_hl:
    ex de,hl
    ld hl,2
    add hl,sp
    ; results
    ld a,(de)
    ld (hl),a
    inc de
    inc hl
    ld a,(de)
    ld (hl),a
    inc de
    inc hl
  ret



  jp +
    my_string:
      .db $12, $34, $56, $78, $9A
    my_zero_string:
      .db $00, $00, $00, $00, $00
  +:
  .macro EVALUATE_BYTE_MOVER
    ld hl,-2 ; return address
    add hl,sp
    ld sp,hl
    ld a,\1
    ld hl,\2
    call move_bytes_from_string_to_stack
  .endm

  EVALUATE_BYTE_MOVER 5, my_string
  ASSERT_TOP_OF_STACK_EQUALS_STRING my_string, 5




  jp +
    my_input_1_120_10_1234:
      .db 1, 120, 10
      .dw $1234
  +:
  ld hl,my_input_1_120_10_1234
  call batch_offset
  ASSERT_A_EQUALS 130

  jp +
    my_input_1_120_20_1234:
      .db 1, 120, 20
      .dw $1234
  +:
  ld hl,my_input_1_120_20_1234
  call batch_offset
  ASSERT_A_EQUALS 140

  jp +
    my_input_2_120_20_30_1234:
      .db 2, 120, 20, 30
      .dw $1234
  +:
  ld hl,my_input_2_120_20_30_1234
  call batch_offset
  ASSERT_A_EQUALS 150

  ; Pass 16 bit and 8 bit parameter in stack
  ; And get 16 bit result from subroutine.
  ld hl,-2
  add hl,sp
  ld sp,hl
  ld hl,$1234
  push hl
  ld a,$56
  push af
  inc sp
  call my_sub
  ld hl,3
  add hl,sp
  ld sp,hl
  ASSERT_TOP_OF_STACK_EQUALS $12 $34
  ;pop hl



  ; And get 16 bit result from subroutine.
  jp +
    my_data:
      .db $12, $34
    my_other_data:
      .db $12, $35, $56
  +:
  ld hl,-2
  add hl,sp
  ld sp,hl
  ld hl,my_data
  call my_sub_gets_hl
  ASSERT_TOP_OF_STACK_EQUALS_BYTES_AT 2 my_data

  ld hl,2
  ld a,l
  ASSERT_A_EQUALS 2

  EVALUATE_BYTE_MOVER 3, my_string
  ASSERT_TOP_OF_STACK_EQUALS_BYTES_AT 3 my_string

  EVALUATE_BYTE_MOVER 4, my_zero_string
  ASSERT_TOP_OF_STACK_EQUALS_BYTES_AT 4 my_zero_string


.macro ASSERT_TOP_OF_STACK_EQUALS_BYTES_AT
  ; Parameters: Number of bytes, pointer to expected data. 
  ld de,\2                    ; Comparison string in DE
  ld hl,0                     ; HL points to top of stack.
  add hl,sp       
  .rept \1                    ; Loop through given number of bytes.
    ld a,(hl)                 ; Get byte from stack.
    ld b,a                    ; Store it.
    ld a,(de)                 ; Get comparison byte.
    cp b                      ; Compare byte on stack with comparison byte.
    jp nz,exit_with_failure   ; Fail if not equal.
    inc hl                    ; Point to next byte in stack.
    inc de                    ; Point to next comparison byte.
  .endr
  .rept \1                    ; Clean stack to leave no trace on the system.
    inc sp        
  .endr
.endm



  call test_size_in_my_frame



jp +  
.dstruct my_frame_1 frame 7 layout_1
layout_1:
    .db -24, -8, 1
    .db -24, 0, 2
    .db -16, -8, 3
    .db -16, 0, 4
    .db -8, -8, 5
    .db -8, 0, 6
    .db -32, -8, 7
+:
  ld hl,my_frame_1
  ld a,1 
  call get_sprite
  ASSERT_HL_EQUALS layout_1 + 3



Tests for the legacy animation struct

.org $1234
fake_animation_table:
    .db 7,
    .dw $1234,
    .db 0
    .db 0
    .dw $0123
    .dw $4567

    .db 6,
    .dw $5678,
    .db 0
    .db 0
    .dw $0123
    .dw $4567


dummy_animation:
  .db 4
  .dw $1111
  .db 9
  .db 9
  .dw $0123
  .dw $4567

ctable1:
  ; item 0
  .db 4
  .dw $1111
  .db 9
  .db 9
  .dw $0123
  .dw $4567
  ; item 1
  .db 5
  .dw $2222
  .db 10
  .db 10
  .dw $0123
  .dw $4567



call test_get_animation_0
call test_get_animation_1
call test_macro
call test_offset_custom_table_0_ctable1
call test_offset_custom_table_1_ctable1
call test_set_animation_load_dummy_to_index0
call test_set_animation_load_dummy_to_index1


test_get_animation_0:
  ld a,0
  call get_animation
  ld a,l
  ASSERT_A_EQUALS $34
ret

test_get_animation_1:
  ld a,1
  call get_animation
  ld a,l
  ASSERT_A_EQUALS $34+$9
ret

test_macro:
  ld hl,$1234
  ASSERT_HL_EQUALS $1234
ret

test_offset_custom_table_0_ctable1
  ld a,0
  ld b,9
  ld hl,ctable1
  call offset_custom_table
  ASSERT_HL_EQUALS ctable1
ret

test_offset_custom_table_1_ctable1
  ld a,1
  ld b,9
  ld hl,ctable1
  call offset_custom_table
  ASSERT_HL_EQUALS ctable1+9
  ld a,(hl)
  ASSERT_A_EQUALS 5
ret

test_set_animation_load_dummy_to_index0:
  ld a,0
  ld hl,dummy_animation
  call set_animation
  ld hl,animation_table
  ld a,(hl)
  ASSERT_A_EQUALS 4
ret

test_set_animation_load_dummy_to_index1:
  ld a,1
  ld hl,dummy_animation
  call set_animation
  ld hl,animation_table+9
  ld a,(hl)
  ASSERT_A_EQUALS 4
ret



  jp +
    ; Example offsetting
    ld d,0
    ld e,actor.id
    ld hl,arthur
    add hl,de
  
  +:

Index the animation table:
    ; index with following if not index = 0
    ; ld de,_sizeof_animation
    ; ld hl,animation_table
    ; ld b,a (index)
    ; -:
    ;   add hl,de
    ; djnz -



Vague initial requirement:
Write a library that can handle objects.

1. Add a metasprite to a given y,x